/*

SUB QUERIES - ALSO CALLED AS NESTED QUERIES

EXPERIMENT 03

EG: QUERY1 (QUERY2(QUERY3))

EXECUTION ORDER: Q3 > Q2 > Q1
INNER QUERY IS EXECUTED FIRST;


QUERY HAS SOME SPECIAL OPERATORS TO USE:
1. = EQUALS TO : WHERE QUERY RETURNS SINGLE VALUE LIKE 9, AMAN, 109.67 - <, >, !=, <>
2. IN : WHERE QUERY RETURNS MULTIPLE ROWS / LIST EG. WHERE CITY IN ('A', 'B', 'C')
3. NOT IN
4. ANY (OR)
5. ALL (AND)


TYPES OF SUB-QUERIES
1. SCALER = SQ WHICH RETURN ONLY 1 VALUE
2. MULTI-VALUE/MULTI-ROW = SQ WHICH RETURNS MULTIPLE ROWS/VALUES
3. SELF-CONTAINED = WHICH DOES NOT HAVE DEPENDENCY ON OUTER QUERY
4. CO-RELATED  = WHICH ARE DEPENDENT ON OUTER QUERY
	Q1(Q2) // WHAT IF Q2 USES ALIAS OF Q1 COLUMN


PLACEMENT OF SUB-QUERY
1. SQ WITHIN WHERE CLAUSE
2. SQ WITH SELECT COMMAND (ALIAS)
3. SQ IN FROM CLAUSE (ALIAS)
*/

-- Q1 FIND THE HIGHEST SECOND SALARY FROM EMPLOYEES TABLE
-- FIND THE MAX(SALARY) --62000
-- WAY1- FIND THE MAX(SALARY) WHERE SALARY NOT IN (62000)
--			SELECT MAX(SALARY) FROM EMPLOYEES WHERE SALARY <> (SELECT MAX(SALARY) FROM EMPLOYEES)



/*

	--1. SCALER SUB QUERY
	SELECT MAX(SALARY) FROM EMP WHERE SALARY <> (SELECT MAX(SALARY) FROM EMP)


	--2. MULTI ROW SQ
	SELECT * FROM EMP WHERE DEPT_ID IN (SELECT ID FROM DEPT WHERE DEPT_NAME='ACCOUNTS') // replacement of joins

	--3. self-contained SQ
	SELECT * FROM EMP WHERE DEPT_ID IN (SELECT ID FROM DEPT WHERE DEPT_NAME='ACCOUNTS') // A SELF CONTAINED AS WELL
	// BECAUSE SELECT ID FROM DEPT WHERE DEPT_NAME='ACCOUNTS'  IS NOT DEPENDENT ON OUTER QUERY


	--4. CO-RELATED SQ
	- ALIAS IS VERY MUCH USED
	- THESE SQ ARE AVOIDED WHEN NOT NEEDED.



	EG:
	// THIS WON'T WORK AS GENDER IS PART OF EMP TABLE
	SELECT * FROM EMP WHERE DEPT_ID IN
	(SELECT ID FROM DEPT WHERE GENDER = 'MALE');

	// THIS WILL WORK BECAUSE OF ALIAS
	SELECT * FROM EMP AS A WHERE A.DEPT_ID IN
	(SELECT B.ID FROM DEPT AS B WHERE A.GENDER='MALE')




	ANY OPERATOR: ACTS AS UPPER BOUND
	SELECT * FROM EMP
	WHERE SALARY < ANY
	(SELECT SALARY FROM EMP WHERE EMP_NAME = 'AMIT' OR EMP_NAME = 'ARUN')


	ALL OPERATOR: ACTS AS LOWER BOUND
	SELECT * FROM EMP
	WHERE SALARY < ALL
	(SELECT SALARY FROM EMP WHERE EMP_NAME = 'AMIT' OR EMP_NAME = 'ARUN')




	Q. Which is better SUB-Queries or JOINS?
	ANS. Joins because in large records retrieval we may need to run many sub-queries which is not a good approach 
			whereas JOINS are an efficient way in such cases.

*/




------------------ Experiment 03 (EASY) ------------------------

-- GENERATE AN EMPLOYEE RELATION WITH ONLY ONE ATTRIBUTE I.E, EMP_ID, EMPLOYEE(EMP_ID)
/*
EMPLOYEE TBL -> 
EMP_ID
2
4
4
6
6
7
8
8

TASK: FIND THE MAX EMP_ID BUT excluding the duplicates
output: 7

*/




CREATE DATABASE EXP3_SUB_QUERIES;

USE EXP3_SUB_QUERIES;

-- EASY

CREATE TABLE TBL_EMPLOYEE (
	EMP_ID INT
);

INSERT INTO TBL_EMPLOYEE
VALUES
(2), (4), (4), (6), (6), (7), (8), (8);


SELECT * FROM TBL_EMPLOYEE;

SELECT MAX(EMP_ID)
FROM TBL_EMPLOYEE
WHERE EMP_ID IN 
(SELECT EMP_ID FROM TBL_EMPLOYEE GROUP BY EMP_ID HAVING COUNT(EMP_ID) = 1);


-- PRACTICE SET
CREATE TABLE TBL_PRODUCTS
(
	ID INT PRIMARY KEY IDENTITY,
	[NAME] NVARCHAR(50),
	[DESCRIPTION] NVARCHAR(250) 
)

CREATE TABLE TBL_PRODUCTSALES
(
	ID INT PRIMARY KEY IDENTITY,
	PRODUCTID INT FOREIGN KEY REFERENCES TBL_PRODUCTS(ID),
	UNITPRICE INT,
	QUALTITYSOLD INT
)

INSERT INTO TBL_PRODUCTS VALUES ('TV','52 INCH BLACK COLOR LCD TV')
INSERT INTO TBL_PRODUCTS VALUES ('LAPTOP','VERY THIIN BLACK COLOR ACER LAPTOP')
INSERT INTO TBL_PRODUCTS VALUES ('DESKTOP','HP HIGH PERFORMANCE DESKTOP')


INSERT INTO TBL_PRODUCTSALES VALUES (3,450,5)
INSERT INTO TBL_PRODUCTSALES VALUES (2,250,7)
INSERT INTO TBL_PRODUCTSALES VALUES (3,450,4)
INSERT INTO TBL_PRODUCTSALES VALUES (3,450,9)


SELECT *FROM TBL_PRODUCTS
SELECT *FROM TBL_PRODUCTSALES

-- TASK 01-> FIND THE ID, NAME, DESCRIPTION OF PRODUCT WHICH HAS NOT BEEN SOLD FOR ONCE.
-- OUTPUT1: ID , NAME, DESCRIPTION


SELECT ID, NAME, DESCRIPTION
FROM TBL_PRODUCTS
WHERE ID NOT IN
(SELECT B.PRODUCTID from TBL_PRODUCTSALES AS B
GROUP BY B.PRODUCTID 
HAVING COUNT(B.QUALTITYSOLD) >= 1)


-- or

select id, name, description
from TBL_PRODUCTS
where id not in 
(select distinct productid from TBL_PRODUCTSALES)



-- TASK02 -> FIND THE TOTAL QUANTITY SOLD FOR EACH RESPECTIVE PRODUCT
-- OUTPUT: NAME  QTY_SOLD (SUM)
--          A       15
-- YOU WILL USE SQ IN SELECT CLAUSE


SELECT A.NAME,(SELECT SUM(QUALTITYSOLD) FROM TBL_PRODUCTSALES WHERE PRODUCTID = A.ID) AS 'QTY SOLD'
FROM TBL_PRODUCTS AS A;




/*

---------------- SET OPERATIONS IN SQL ----------------

SET = TABLE

OPERATION:
1. UNION
2. UNION ALL
3. INTERSECT (INNER JOIN)
4. (A-B): EXCEPT



RULES:
1. WHICHEVER COLUMN INVOLVED IN THE OPERATION MUST HAVE SAME DATATYPE

select * from a
union
select * from b;

select id, name from a
union 
select name, id from b;

*/


-------------------------- Medium --------------------------------
CREATE TABLE department (
    id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

-- Create Employee Table
CREATE TABLE employee (
    id INT,
    name VARCHAR(50),
    salary INT,
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES department(id)
);


-- Insert into Department Table
INSERT INTO department (id, dept_name) VALUES
(1, 'IT'),
(2, 'SALES');

-- Insert into Employee Table
INSERT INTO employee (id, name, salary, department_id) VALUES
(1, 'JOE', 70000, 1),
(2, 'JIM', 90000, 1),
(3, 'HENRY', 80000, 2),
(4, 'SAM', 60000, 2),
(5, 'MAX', 90000, 1);


Select d.dept_name, e.name, e.salary
from
employee as e
inner join 
department d
on e.department_id = d.id
where e.salary in 
(select max(salary) from
employee group by department_id);

-- or


Select e.name, d.dept_name, e.salary 
from
employee as e
inner join 
department d
on e.department_id = d.id
where e.salary in 
(Select max(salary) from 
employee where department_id = e.department_id)
order by d.dept_name;


-- HARD: GIVEN TWO TABLES OUTPUT THEM AS FOLLOWS:

CREATE TABLE TBL_A (
	EMP_ID INT PRIMARY KEY,
	E_NAME VARCHAR(20),
	SALARY INT
);

CREATE TABLE TBL_B (
	EMP_ID INT PRIMARY KEY,
	E_NAME VARCHAR(20),
	SALARY INT
);

INSERT INTO TBL_A
VALUES
	(1, 'AA', 1000),
	(2, 'BB', 300);

INSERT INTO TBL_B
VALUES
	(2, 'BB', 400),
	(3, 'CC', 100);

/*
OUTPUT- 
EMP_ID E_NAME SALARY
1       AA      1000
2       BB      300 (MIN)
3       CC      100
*/

SELECT EMP_ID, E_NAME, MIN(SALARY)
FROM(
SELECT * FROM TBL_A AS A
UNION ALL
SELECT * FROM TBL_B AS B
) AS RES
GROUP BY EMP_ID, E_NAME;
